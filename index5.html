<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>Timeseries data webapp</h1>
<ol type="A">
	<li>Select a timeseries data source.</li>
	<li>View fetched data.</li>
	<li>Select a model to perform timeseries prediction.</li>
	<li>Predict future time points, evaluate error.</li>
</ol>

<!-- ---------------------------------------- -->
<!-- View two split window -->
<div align="left">
<table style='text-align: left; width: 500px; display:block'>
<tr>

<th id="timeseries_input">

<h3>[Step 0] Select an input timeseries data source.</h3>
<!-- Drop down menu -->
<label for="select_timeseries_data_source">Select a timeseries data source:</label>
<select name="timeseries_data_source" id="timeseries_data_source" style="display:block">
  <option value="---">Select an option</option>
  <option value="Weather_prediction">Weather prediction</option>
  <option value="Custom_URL_endpoint">Custom prediction</option>
</select>
	
<input id="LOCATION" type="text" value="" placeholder="LOCATION: Enter City, Country" rows="10" cols="100" style="display:none; text-align: left; width: 600px;">

<br><br>
	
<h3>[Step 1] View the selected timeseries data.</h3>
<button id="view_fetched_data" onclick="view_fetched_data()">View Fetched Data</button>
  
<br><br>

<h3>[Step 2] Predict future datapoints of the timeseries data.</h3>
<!-- Drop down menu -->
<label for="select_model_type">Select a desired model:</label>
<select name="model_type" id="model_type" style="display:block">
  <option value="LSTM">LSTM</option>
  <option value="Forecasting">Forecasting</option>
  <option value="Transformer_based">Transformer_based</option>
</select>
<br>
<button id="predict" onclick="predict()">Predict</button>
<br>
<progress id="progress_bar" max="100" value="0" style="display:none">0%</progress>

<!-- ---------------------------------------- -->

<th id="timeseries_output">
<h3>[Steps 1 & 2] View Results.</h3>
<div id="data_display" style="display:block; text-align: left; width: 600px; height: 600px">
<br>
<div id="notification"></div>
<br>
<div id="error"></div>
</th>
	
</tr>
</table>
</div>  
<!-- ---------------------------------------- -->



<!-- ---------------------------------------- -->
<!-- CSS -->
<style>
div { padding: 10px; display:block; font-family:courier; font-size:15px; }
div#notification { position: relative; color: #3236a8; }
div#error { position: relative; color: #bd1f17; }

table {vertical-align: top; border-collapse: collapse; position: relative; z-index: 0; border: 0px solid black;}

tr {vertical-align: top; border: 0px solid black; padding: 30px 30px; }

th, td {vertical-align: top; border: 0px solid black; padding: 10px; }
th#timeseries_input {width: 100%; }
th#timeseries_output {width: 100%; }

div#data_display {position: absolute; vertical-align: top; top: 200; z-index: 200; }
</style>

<!-- ---------------------------------------- -->


<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

<script src="https://cdn.plot.ly/plotly-2.30.0.min.js" charset="utf-8"></script>
	
<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
	window.location.href = window.location.href + '?nocache=' + new Date().getTime();

	document.getElementById("timeseries_data_source").selectedIndex = 0;
	document.getElementById("LOCATION").value = "";
	
});

// -----------------------------------------------

async function processEvent_timeseries_data_source(event) {
	
	if (document.getElementById("timeseries_data_source").selectedIndex == 1) {
		document.getElementById("LOCATION").style.display = 'block';
	} else {
		document.getElementById("LOCATION").style.display = 'none';
	}
}


document.getElementById("timeseries_data_source").addEventListener("change", processEvent_timeseries_data_source, false);
	
// -----------------------------------------------

var array_object = [];

async function view_fetched_data() {

	// Obtain timeseries data
	var timeseries_data_source = document.getElementById("timeseries_data_source").value;
	// console.log('timeseries_data_source: ', timeseries_data_source);

	if (timeseries_data_source == 'Weather_prediction') {
		var LOCATION = document.getElementById("LOCATION").value;
		// console.log('LOCATION: ', LOCATION);
		
		var Lat_lon_arr = await GET_LATITUDE_LONGITUDE(LOCATION);
		var latitude = Lat_lon_arr.shift();
		// console.log('latitude: ', latitude);
		// console.log('longitude: ', Lat_lon_arr);
		
		array_object = await GET_weather_timeseries_data(latitude, Lat_lon_arr);
		console.log('array_object: ', array_object);

		// -----------------------------------------------
	
		var past_temperature_data = array_object[0].temperature_2m;
		past_temperature_data = past_temperature_data.flat();
		var t1 = await Array.from({length: past_temperature_data.length}, (val, ind) => { return ind; });
		
		// Print the [first datapoint of] 24 hour predictions from the site
		var predicted_24hour_temperature_data = array_object[1].temperature_2m;
		predicted_24hour_temperature_data = predicted_24hour_temperature_data.flat();
		var t2 = await Array.from({length: predicted_24hour_temperature_data.length}, (val, ind) => { return (past_temperature_data.length-1) + ind; });
	
		// -----------------------------------------------

		// https://plotly.com/javascript/line-charts/
		var title_text = "Timeseries: temperature per hour";
		var x_text_trace1and2 = "Time (hour)";
		var y_text_trace1and2 = "Temperature (Celsius)";
		var trace1 = {x: t1, y: past_temperature_data, mode: 'lines+markers', type: 'line', name: 'Past temperature points'};
		var trace2 = {x: t2, y: predicted_24hour_temperature_data, mode: 'lines+markers', type: 'line', name: 'Predicted temperature points'};
		var data = [trace1, trace2];
		var layout = {grid: {rows: 1, columns: 1, pattern: 'independent'}, title: title_text, xaxis: {title: x_text_trace1and2}, yaxis: {title: y_text_trace1and2}};
		Plotly.newPlot('data_display', data, layout);
	
		// -----------------------------------------------
		
	} else if (timeseries_data_source == 'Custom_URL_endpoint') {
		document.getElementById('notification').innerHTML = "In progress.";
		
	} else {
		document.getElementById('notification').innerHTML = "Please select a timeseries data source."; 
	}
	
}

	
	
async function predict() {

	if (array_object.length == 0) {
		document.getElementById('notification').innerHTML = "Please select a timeseries data source and View the data.";
	} else {
		// -----------------------------------------------
		// Time series prediction, like regression, is different than classification because [Y is composed of X]. 
		// One needs to separate Y from X, using the [batch_size, timestep, num_of_features] organizaton, then restack X.
		// -----------------------------------------------
	
		// Prepare the X matrix
	
		// open_meteo_past_data:
		var xs_2d_arr = [array_object[0].temperature_2m];
		console.log('xs_2d_arr: ', xs_2d_arr);
		
		var shap = await shape(xs_2d_arr);
		console.log('Shape xs_2d_arr: ', shap);
		// Array: 1 row=num_of_features, 240 columns=num_of_datapoints
	
		// -------------------------------------------------
			
		// X matrix should be shape [num_of_datapoints, num_of_features], but I am going to leave it.
	
		// -------------------------------------------------
	
		// Calculate [batch_size, timestep, num_of_features] to separate X and Y
		// var timesteps = 6;  // will need to put in timesteps=5 into the model, since we use the 6th one to assign to Y
		// OR
		var timesteps = 12; // Try a longer window such that the LSTM has more past data to train on, for a more accurate result
		console.log('timesteps: ', timesteps);
		
		var num_of_features = xs_2d_arr.length;  // num_of_features_OR_colnum
		console.log('num_of_features: ', num_of_features);
	
		var batch_size = Math.floor(xs_2d_arr[0].length / timesteps);
		console.log('batch_size: ', batch_size);
		
		// -------------------------------------------------
		
		var xs_3d_train = [];
		var ys_2d_train = [];
		var xs_3d_test = [];
	
		var batch_size_test = 0;
		
		for (var feats=0; feats<num_of_features; feats++) {
			// for the organization, features are rows
			var temp_datappoints_arr = xs_2d_arr.at(feats);
	
			// cut temp_datappoints_arr into X and Y, every timesteps
			var x_temp = [];
			var y_temp = [];
			var x_temp_test = [];
			
			for (var num_of_desired_predictions=0; num_of_desired_predictions<batch_size; num_of_desired_predictions++) {
				var st = num_of_desired_predictions * timesteps;
				var stop = st + timesteps;
				
				if (num_of_desired_predictions == batch_size-1) {
					// Test data set
					x_temp_test.push(temp_datappoints_arr.slice(st, stop-1));
					batch_size_test = batch_size_test + 1;
				} else {
					// Train data set
					x_temp.push(temp_datappoints_arr.slice(st, stop-1));
					y_temp.push(temp_datappoints_arr.at(stop));
				}
			}
			xs_3d_train.push(x_temp);
			ys_2d_train.push(y_temp);
			xs_3d_test.push(x_temp_test);
		}
		
		// Train shape1
		shap = await shape(xs_3d_train);  
		console.log('Shape xs_3d_train: ', shap);  // [num_of_features, batch_size, timesteps] = [ 1, 39, 5 ]
	
		shap = await shape(ys_2d_train);
		console.log('Shape ys_2d_train: ', shap); // [num_of_features, batch_size] = [ 1, 39 ]
	
		// -------------------------------------------------
	
		// Test shape1
		shap = await shape(xs_3d_test);  
		console.log('Shape xs_3d_test: ', shap);  // [num_of_features, batch_size, timesteps] = [ 1, 39, 5 ]
	
		// -------------------------------------------------
	
		// Update timesteps, timesteps should be 1 less due to assigning the last datapoint to Y.
		timesteps = timesteps - 1;
		console.log('timesteps: ', timesteps);
	
		// 1 less to account for the x_test data set, the x_test dataset is removed to test the next hourly temperature prediction
		batch_size = batch_size - 1;
		console.log('batch_size: ', batch_size);
		
		// -------------------------------------------------
		
		// Put X_3d_test_shape1 [num_of_features, batch_size, timesteps]=[0,1,2] into [batch_size, timesteps, num_of_features]=[1,2,0]
		
		var xs_3d_arr = await exchange_3d_dimensions(xs_3d_train, [1,2,0]);
	
		// Train shape
		shap = await shape(xs_3d_arr);  
		console.log('Shape xs_3d_arr: ', shap);
	
		xs_3d_arr = await tf.tensor(xs_3d_arr);
		console.log('Tensorflow tensor (X train) - xs_3d_arr: ', xs_3d_arr);
		
		// -------------------------------------------------
	
		console.log('batch_size_test: ', batch_size_test);
		
		var xs_test_3d_arr = await exchange_3d_dimensions(xs_3d_test, [1,2,0]);
	
		// Test shape - [ batch_size=1, timesteps, 1 ]
		shap = await shape(xs_test_3d_arr);  
		console.log('Shape xs_test_3d_arr: ', shap);
	
		xs_test_3d_arr = await tf.tensor(xs_test_3d_arr);
		console.log('Tensorflow tensor (X test) - xs_test_3d_arr: ', xs_test_3d_arr);
		
		// -------------------------------------------------
		
		// Assign Y to a 1D tensor
		console.log('ys_2d_train: ', ys_2d_train);	// [num_of_features, batch_size] = [ 1, 39 ]
	
		// So, need to stack [batch_size] per [feature]
		var ys_1d_arr = [];
		for (var i=0; i<num_of_features; i++) { ys_1d_arr = ys_1d_arr.concat(ys_2d_train[i]); }
		
		ys_1d_arr = await tf.tensor(ys_1d_arr);
		console.log('Tensorflow tensor (Y train) - ys_1d_arr: ', ys_1d_arr);
		
		// Test shape
		shap = await shape(ys_1d_arr);  
		console.log('Shape ys_1d_arr: ', shap);
		
		// -----------------------------------------------
		
		// Predict future data points
		var model_type = document.getElementById("model_type").value;
	
		if (model_type == 'LSTM') {
	
			var num_of_outputs = 1; // a value from 1 to timesteps, or the number of data points to predict into the future
	
			// ------------------------
	
			const case_num = 1;
			
			var n_a = timesteps;
			var lstmModel = [];
	
			if (case_num == 0) {
	
				// Case 0: predictions for all the data points in the timestep per batch (most basic model)
				// const input = tf.input({shape: [timesteps, num_of_features]});
				// Please provide either a `shape` or `batchShape` argument to Input, but not both.
				// OR
				const input = tf.input({batchShape: [batch_size, timesteps, num_of_features]});
				
				console.log(JSON.stringify(input.shape));  // [19=batch_size, 11=timesteps, 1=num_of_features]
				
				
			} else if (case_num == 1) {
				
				// Case 1: one data point prediction at the end of the timestep per batch (most basic model)
				// const input = tf.input({shape: [timesteps, num_of_features]});
				// Please provide either a `shape` or `batchShape` argument to Input, but not both.
				// OR
				const input = tf.input({batchShape: [batch_size, timesteps, num_of_features]});
				console.log(JSON.stringify(input.shape));  // [null,5,1]
				
				const lstm = tf.layers.lstm({
					recurrentActivation: 'hardSigmoid',
					units: n_a,
					returnSequences: false,
					returnState: false,
					kernelInitializer: 'heNormal',
					batchSize: batch_size,
					inputShape: [timesteps, num_of_features],
					stateful: true,
					activation: 'tanh'
				});
				console.log(JSON.stringify(lstm.apply(input).shape)); // [null,5]
				
				const denseLayer1 = tf.layers.dense({units: num_of_outputs});
				
				const output = denseLayer1.apply(lstm.apply(input));
				console.log("LSTM model output shape: ", JSON.stringify(output.shape));  // [null,1]
				
				lstmModel = await tf.model({inputs: input, outputs: output});
				
	
			} else if (case_num == 2) {
				
				// Case 2: Classification prediction of timeseries class - one data point prediction at the end of the timestep per batch
				var num_of_classes = 2;  // 2 or more
				const lstm = tf.layers.lstm({units: n_a, returnSequences: false});
				const denseLayer1 = tf.layers.dense({units: num_of_classes, activation: 'softmax'});
				const output = denseLayer1.apply(lstm.apply(input));
				console.log("LSTM model output shape: ", JSON.stringify(output.shape));  // [batch_size, timesteps, n_a]
				lstmModel = await tf.model({inputs: input, outputs: output});
			}
	
			console.log('lstmModel: ', lstmModel);
			
			// ------------------------
			
			await lstmModel.compile({optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: ['mse'],});
	
			// ------------------------
	
			const epochs = 400;
			const history = await lstmModel.fit(xs_3d_arr, ys_1d_arr, { 
						batchSize: batch_size, 
						epochs: epochs, 
						callbacks: { onEpochEnd: async (epoch, logs) => { 
							if (epoch % 50 == 0) { 
								document.getElementById("progress_bar").style.display = "block";
								document.getElementById("progress_bar").value = epoch/epochs*100;
								console.log('epoch: ', epoch);
								// console.log('logs: ', logs); 
							} 
						}}
					});
			console.log('history: ', history);
			
			document.getElementById("progress_bar").style.display = "none";
			
	
			// ------------------------
			// Print prediction from LSTM model
			// ------------------------
			// Forecasting loop
			const num_of_predictions = 1;
			var preds = [];
			for (var loop=0; loop<num_of_predictions; loop++) {

				console.log('xs_test_3d_arr: ', xs_test_3d_arr);
				
				// Evaluation of prediction with respect to the model
				var result = lstmModel.predict( xs_test_3d_arr ); // []
				// console.log('result : ', result);
	
				// ------------------------
	
				// Obtain prediction output from model
				// const output_value0 = await result.data();
				// console.log('output_value0 : ', output_value0);
				// OR
				var output_value = result.dataSync()[0];  
				// console.log('output_value : ', output_value);
	
				// ------------------------
				
				preds.push(output_value);
	
				// ------------------------
			}
			
			console.log('preds : ', preds);
			
			// ------------------------
	
			document.getElementById('notification').innerHTML = "LSTM model prediction: " + preds + ".  ";
			
			// ------------------------
			
		} else if (model_type == 'Forecasting') {
			
			// Regression is a one-to-one mapping of x corresponding to y.
			// So construct ys by shifting xs to the right to predict the next time point
	
			// xs_2d_arr Array: 1 row=num_of_features, 240 columns=num_of_datapoints
	
			// ------------------------
			
			// transpose xs_2d_arr [num_of_features, num_of_datapoints] to obtain shape [num_of_datapoints, num_of_features]
			xs_2d_arr = await transpose_2d_array(xs_2d_arr);
	
			// ------------------------
	
			shap = await shape(xs_2d_arr);  
			console.log('Shape xs_2d_arr: ', shap);
			
			// ------------------------
	
			var num_of_datapoints = shap[0];
	
			// ------------------------
			
			var xs_flat = [];
			for (var i=0; i<num_of_datapoints; i++) {
				for (var j=0; j<num_of_features; j++) {
					xs_flat.push(xs_2d_arr[i][j]);
				}
			}
			console.log('xs_flat: ', xs_flat);
	    
			shap = await shape(xs_flat);  
			console.log('Shape xs_flat: ', shap);
	
			// ------------------------

			// This is just one model to predict the next data point.
			// One can make several models, shift the data by two points and predict every other point.
			// OR
			// Add a new feature for each data shift, to predict 'features_datashift' at one time
			var data_point_shift_between_X_and_Y = 1;
			
			var repeated_last_value = await Array.from({length: data_point_shift_between_X_and_Y}, (val, ind) => { return xs_flat.at(xs_flat.length-1); });
			
			var ys_1d_arr = xs_flat.slice(data_point_shift_between_X_and_Y, xs_flat.length).concat(repeated_last_value);
	
			shap = await shape(ys_1d_arr);  
			console.log('Shape ys_1d_arr: ', shap);
	
			// ------------------------
	
			// Make xs_2d_arr a tensor
			xs_2d_arr = await tf.tensor(xs_2d_arr);
			
			// Make ys_1d_arr a tensor
			ys_1d_arr = await tf.tensor(ys_1d_arr);
			
			// ------------------------
			
			const num_of_outputs = 1;
	
			// Regression model
			const input = tf.input({shape: [num_of_features]}); 
			const denseLayer1 = tf.layers.dense({units: 64, activation: 'relu'});
			const denseLayer2 = tf.layers.dense({units: 64, activation: 'relu'});
			const denseLayer3 = tf.layers.dense({units: 64, activation: 'relu'});
			const denseLayer4 = tf.layers.dense({units: num_of_outputs});  
			const output = denseLayer4.apply(denseLayer3.apply(denseLayer2.apply(denseLayer1.apply(input))));
			const Regmodel = tf.model({inputs: input, outputs: output});
	
			console.log('Regmodel: ', Regmodel);
	
			await Regmodel.compile({optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: ['mse'],});
	
			// ------------------------
	
			const batchSize = 1;
			const epochs = 200;
			const history = await Regmodel.fit(xs_2d_arr, ys_1d_arr, { 
						batchSize: batchSize, 
						epochs: epochs, 
						callbacks: { onEpochEnd: async (epoch, logs) => { 
							if (epoch % 50 == 0) {
								document.getElementById("progress_bar").style.display = "block";
								document.getElementById("progress_bar").value = epoch/epochs * 100;
								console.log('epoch: ', epoch); 
							}
							// console.log('logs: ', logs); 
						}} 
					});
			console.log('history: ', history);

			document.getElementById("progress_bar").style.display = "none";
	
			// ------------------------
			// Print prediction
			// ------------------------
			var test_data = xs_flat.slice(xs_flat.length-1-batchSize, xs_flat.length-1);
			console.log('test_data: ', test_data);
			
			const xs_test_3d_arr_reg = await tf.reshape(test_data, [batchSize, num_of_features]);
			// needs to be shaped into [num_of_datapoints=batchSize, num_of_features=1]
			
			// Evaluation of prediction with respect to the model
			const result = Regmodel.predict( xs_test_3d_arr_reg );
			console.log('result : ', result);
	
			// ------------------------
	
			const output_value0 = await result.data();
			console.log('output_value0 : ', output_value0);
			
			const output_value = result.dataSync();  
			console.log('output_value : ', output_value);
	
			// ------------------------
	
			document.getElementById('notification').innerHTML = "Regression model prediction: " + output_value + ".  ";
			
			// ------------------------
			
			
		} else if (model_type == 'Transformer_based') {
			document.getElementById('notification').innerHTML = "model_type In progress.";
			
		} else {
			document.getElementById('notification').innerHTML = "Please select a model type for timeseries prediction."; 
		}
		
		// -----------------------------------------------
	
		// Print the [first datapoint of] 24 hour predictions from the site
		var predictions = array_object[1].temperature_2m.at(0);
		document.getElementById('notification').innerHTML += "Site prediction: " + predictions;
		
		// -----------------------------------------------
	}
}
	
// -----------------------------------------------




	



// -----------------------------------------------
// SUBFUNCTIONS
// -----------------------------------------------
async function recur_func(arr) {
	if (arr != undefined) {
		return [arr[0], arr.length];
	} else {
		return arr;
	}
}
	
async function shape(arr) {
	var out = await recur_func(arr);
	var shap = [out[1]];
	var c = 0; // typically work with 4D arrays or less
	while (out != undefined && c < 4) {
		out = await recur_func(out[0]);
		if (out != undefined) {
			shap.push(out[1]);
		}
		c = c + 1;
	}

	if (shap.length > 1) {
		shap = shap.slice(0, shap.length-1);
	}
	
	return shap;
}

// -----------------------------------------------

async function zeros(dims) {

	// dims: [desired_0th_dim, desired_1st_dim, desired_2nd_dim]

	var out = [];
	
	if (dims.length == 1) {
		var desired_0th_dim = dims.at(0);
		
		out = Array.from({length: desired_0th_dim}, (val, ind) => { return 0; }); 

	} else if (dims.length == 2) {
		var desired_0th_dim = dims.at(0);
		var desired_1st_dim = dims.at(1);
		
		for (var i=0; i<desired_0th_dim; i++) {
			var arr = Array.from({length: desired_1st_dim}, (val, ind) => { return 0; }); 
			out.push(arr);
		}

	} else if (dims.length == 3) {
		var desired_0th_dim = dims.at(0);
		var desired_1st_dim = dims.at(1);
		var desired_2nd_dim = dims.at(2);
		
		for (var i=0; i<desired_0th_dim; i++) {
			temp = [];
			for (var j=0; j<desired_1st_dim; j++) {
				var arr = Array.from({length: desired_2nd_dim}, (val, ind) => { return 0; }); 
				temp.push(arr);
			}
			out.push(temp);
		}
		
	} else {
		console.log('Enter an array of length 1, 2, or 3. (ie: [desired_0th_dim, desired_1st_dim, desired_2nd_dim])')
	}
	
	return out;
}
	
// -----------------------------------------------
			
async function exchange_3d_dimensions(arr_3d, output_dims_index) {

	// dims: [2,1,2] implying the output dimension size
	// OR
	// output_dims_index: [0,2,1] implying how to switch the dimension index of arr_3d, this is technically more precise because two dimension indexes could have the same size. So one is specifying exactly which dimension index to use for a particular dimension.

	// Way 0
	// dims notation [2,2,1] => [2,1,2] 
	
	// Way 1
	// need to say which dimension should switch with, which dimension
	// output_dims_index specifies the [dimension index] of the desired output array 
	// [2,2,1] = [org_0th_dim, org_1st_dim, org_2nd_dim] => [2,1,2] = [org_0th_dim, org_2nd_dim, org_1st_dim] = [0,2,1] 

	
	// [0] List the original array location_values and values
	var org_0th_dim = [];
	var org_1st_dim = [];
	var org_2nd_dim = [];
	var val = [];

	for (var i=0; i<arr_3d.length; i++) {
		for (var j=0; j<arr_3d[0].length; j++) {
			for (var k=0; k<arr_3d[0][0].length; k++) {
			       org_0th_dim.push(i);
			       org_1st_dim.push(j);
			       org_2nd_dim.push(k);
			       val.push(arr_3d[i][j][k])
			}
		}
	}
	// console.log('org_0th_dim: ', org_0th_dim);
	// console.log('org_1st_dim: ', org_1st_dim);
	// console.log('org_2nd_dim: ', org_2nd_dim);
	// console.log('val: ', val);
	
	// Need to transform output_dims_index, from index to dimensions
	var dims_of_org_arr = [arr_3d.length, arr_3d[0].length, arr_3d[0][0].length];
	var dims = output_dims_index.map((val, i) => { return dims_of_org_arr.at(val); });
	
	
	// [1] Make the new shape array, filled with zeros
	var desired_3d = await zeros(dims);

	// Exchange notation for desired output index dimensions
	var all = [org_0th_dim, org_1st_dim, org_2nd_dim];
	var all_switched = output_dims_index.map((val, i) => { return all.at(val); });
	org_0th_dim = all_switched.at(0);
	org_1st_dim = all_switched.at(1);
	org_2nd_dim = all_switched.at(2);

	
	// [2] Fill in output shaped 3d array
	var desired_0th_dim = dims.at(0);
	var desired_1st_dim = dims.at(1);
	var desired_2nd_dim = dims.at(2);
	
	for (var i=0; i<desired_0th_dim; i++) {
		for (var j=0; j<desired_1st_dim; j++) {
			for (var k=0; k<desired_2nd_dim; k++) {
				
				// cycle over the index of a for every i,j,k value
			       for (var ind=0; ind<org_0th_dim.length; ind++) {
				       if (org_0th_dim.at(ind) == i && org_1st_dim.at(ind) == j && org_2nd_dim.at(ind) == k) {
						desired_3d[i][j][k] = val.at(ind);
				       }
			       }
			}
		}
	}
			       
	return desired_3d;       
}
  
// -----------------------------------------------

async function transpose_2d_array(arr) {

	var transpose_colNum = arr.length;
	var transpose_rowNum = arr.at(0).length;
	var transpose_arr = [];
	for (var i=0; i<transpose_rowNum ; i++) {
		const col = Array.from({ length: transpose_colNum }, (_, i) => 0);
		transpose_arr.push(col);
	}
	
	for (var i=0; i<arr.length; i++) {
		for (var j=0; j<arr.at(i).length; j++) {
			transpose_arr[j][i] = arr[i][j];
		}
	}
	return transpose_arr;
}

// -----------------------------------------------
	
async function GET_LATITUDE_LONGITUDE(LOCATION) {
	
	// [Step 0] Get latitude and longitude
	// https://maps.googleapis.com/maps/api/geocode/json?address=${address}&key=${GCP_API_KEY}
	// OR
	// https://nominatim.org/release-docs/latest/api/Search/
	var url = `https://nominatim.openstreetmap.org/search?q=${LOCATION}&format=json`;
	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var headers = {};
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	var out = await fetch_CORS(url, method, data, headers, return_type);
	console.log('out: ', out); 

	// Parse for correct location: choose the first location because it will be most precise
	return [Number(out[0].lat), Number(out[0].lon)];
}

// -----------------------------------------------
	
async function GET_weather_timeseries_data(latitude, longitude) {
	
	// [Step 0] Get weather data
	// https://open-meteo.com/en/docs
	// The API endpoint /v1/forecast accepts a geographical coordinate, a list of weather variables and responds with a JSON hourly weather forecast for 7 days. Time always starts at 0:00 today and contains 168 hours. If &forecast_days=16 is set, up to 16 days of forecast can be returned.

	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var headers = {};
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'

	// --------------------------------
	
	// Obtain weather [temperature] data from the past (Prediction)
	// Return temperature every hour for the [previous 2 days OR more], such that the next day can be predicted
	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m&past_days=10&forecast_days=0`;
	var open_meteo_past_data = await fetch_CORS(url, method, data, headers, return_type);
	console.log('open_meteo_past_data: ', open_meteo_past_data);

	// --------------------------------
	
	// Obtain weather [temperature] predictions by open-meteo (Actual)
	// Return temperature every hour for the next day
	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m&past_days=0&forecast_days=1`;
	var open_meteo_predictions = await fetch_CORS(url, method, data, headers, return_type);
	console.log('open_meteo_predictions: ', open_meteo_predictions);

	return [open_meteo_past_data.hourly, open_meteo_predictions.hourly];
}

// -----------------------------------------------

async function fetch_CORS(url, method, data, headers, return_type) {

	// url: url address
	// method: 'GET', 'POST'
	// data: required data format for url address
	var w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	// return_type: json, blob, arrayBuffer, text

	// --------------------------------

	// Determine request method
	var headers_final = {
		"Content-Type": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};

	
	headers_final = Object.assign({}, headers_final, headers);
	
	var options = { 
		method : method,
		mode: 'cors',
		headers: new Headers(headers_final),
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

	if (method == 'POST') {
		options.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.json())
				.then(async function(data) { return data; })
				.catch(error => console.error("error: ", error));
		} else { 
			return await fetch(url, options)
				.then(response => response.json())
				.then(async function(data) { return data; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'arrayBuffer') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { return arraybuffer; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { return arraybuffer; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'text') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		}

	} else if (return_type == 'html') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		}
	}

	// --------------------------------
}

// -----------------------------------------------

async function define_proxy_handler() {
	// Parameters to influence Response Header
	// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
	const handler = {
		apply: function(target, thisArg, args) {
			// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
			const [url, options] = args;
			if (options && options.headers) {
				options.headers['Access-Control-Allow-Origin'] = '*';
				options.headers['Access-Control-Allow-Credentials'] = false;
				options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
				// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
				options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
				options.headers['Access-Control-Max-Age'] = 0;
			} else {
				args[1] = {
					headers: { 
						'Access-Control-Allow-Origin': '*',
						'Access-Control-Allow-Credentials': false,
						'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
						'Access-Control-Allow-Headers': 'Content-Type, Authorization',
						'Access-Control-Max-Age': 0
					}
				};
			}
			// console.log('args: ', args);
			return Reflect.apply(target, thisArg, args);
		}
	};

	// Proxy sturcture works! 
	// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
	// The constant variable is called as a function, where it resolves promises. 
	// Call the constant variable proxy3 as a function to resolve the promise correctly
	return await new Proxy(fetch, handler);
}

// -----------------------------------------------


</script>
</body>
</html>
