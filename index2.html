<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>Timeseries data webapp</h1>
<ol type="A">
	<li>Select a timeseries data source.</li>
	<li>View fetched data.</li>
	<li>Select a model to perform timeseries prediction.</li>
	<li>Predict future time points, evaluate error.</li>
</ol>

<br>
	
<!-- Drop down menu -->
<label for="select_timeseries_data_source">Select a timeseries data source:</label>
<select name="timeseries_data_source" id="timeseries_data_source" style="display:block">
  <option value="---">Select an option</option>
  <option value="Weather_prediction">Weather prediction</option>
  <option value="Custom_URL_endpoint">Custom prediction</option>
</select>
	
<input id="LOCATION" type="text" value="" placeholder="LOCATION: Enter City, Country" rows="10" cols="100" style="display:none; text-align: left; width: 600px;">

<br>
	
<button id="view_fetched_data" onclick="view_fetched_data()">View Fetched Data</button>
  
<br>
	
<!-- Drop down menu -->
<label for="select_model_type">Select a desired model:</label>
<select name="model_type" id="model_type" style="display:block">
  <option value="LSTM">LSTM</option>
  <option value="Forecasting">Forecasting</option>
  <option value="Transformer_based">Transformer_based</option>
</select>

<br>
  
<button id="predict" onclick="predict()">Predict</button>

<div id="notification"></div>
<div id="error"></div>

<!-- --------------------------------------------------- -->
<style>
div { padding: 10px; display:block; font-family:courier; font-size:15px; }
div#notification { position: relative; color: #3236a8; }
div#error { position: relative; color: #bd1f17; }
</style>
	
<!-- --------------------------------------------------- -->


<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
	
<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
	window.location.href = window.location.href + '?nocache=' + new Date().getTime();

	document.getElementById("timeseries_data_source").selectedIndex = 0;
	document.getElementById("LOCATION").value = "";
	
});

// -----------------------------------------------

async function processEvent_timeseries_data_source(event) {
	
	if (document.getElementById("timeseries_data_source").selectedIndex == 1) {
		document.getElementById("LOCATION").style.display = 'block';
	} else {
		document.getElementById("LOCATION").style.display = 'none';
	}
}


document.getElementById("timeseries_data_source").addEventListener("change", processEvent_timeseries_data_source, false);
	
// -----------------------------------------------
	
async function view_fetched_data() {

	// Obtain timeseries data
	var timeseries_data_source = document.getElementById("timeseries_data_source").value;
	console.log('timeseries_data_source: ', timeseries_data_source);

	if (timeseries_data_source == 'Weather_prediction') {
		var LOCATION = document.getElementById("LOCATION").value;
		console.log('LOCATION: ', LOCATION);
		
		var Lat_lon_arr = await GET_LATITUDE_LONGITUDE(LOCATION);
		var latitude = Lat_lon_arr.shift();
		console.log('latitude: ', latitude);
		console.log('longitude: ', Lat_lon_arr);
		
		var array_object = await GET_weather_timeseries_data(latitude, Lat_lon_arr);
		
	} else if (timeseries_data_source == 'Custom_URL_endpoint') {
		document.getElementById('notification').innerHTML = "In progress.";
		
	} else {
		document.getElementById('notification').innerHTML = "Please select a timeseries data source."; 
	}

	// -----------------------------------------------

	// Prepare the X matrix

	// open_meteo_past_data:
	var xs_2d_arr = [array_object[0].temperature_2m];  // stack in other features as [feature0, feature1, ...]
	console.log('xs_2d_arr: ', xs_2d_arr);

	var timesteps = 6;
	console.log('timesteps: ', timesteps);
	
	var featureNum = xs_2d_arr.length;  // num_of_features_OR_colnum
	console.log('featureNum: ', featureNum);
	
	var batch_size = Math.floor(xs_2d_arr[0].length / timesteps);
	console.log('batch_size: ', batch_size);

	// Way 0: focus on batch_size and fold the data with respect timesteps => [batch_size, timesteps]
	// Disadvantage: it assumes one feature and does not calculate for the case of more than one feature
	// const xs_2d_arr = await transform_1D_to_2D_batch_size_by_timesteps(X_1d_arr, batch_size, timesteps);
	// console.log('xs_2d_arr: ', xs_2d_arr);

	// Way 1: First focus on folding the data by [featureNum, timesteps], then stack up these 2D arrays per batch_size
	// Tensorflow.js (tf.layers.lstmCell): "Create an input with [timesteps] time steps and a length-[featureNum] vector at each step.". 
	// So it means that [featureNum] are the rows, and [timesteps] are the columns; this way is easy to write.
	var x_batchSize_by_featureNum_by_timesteps = [];
	for (var i=0; i<batch_size; i++) {
		var x_featureNum_by_timesteps = [];
		for (var j=0; j<featureNum; j++) {
			var x_timesteps = [];
			for (var k=0; k<timesteps; k++) {
				x_timesteps.push(X_1d_arr[j].at(k));
			}
			x_featureNum_by_timesteps.push(x_timesteps);
		}
		x_batchSize_by_featureNum_by_timesteps.push(x_featureNum_by_timesteps);
	}
	console.log('x_batchSize_by_featureNum_by_timesteps: ', x_batchSize_by_featureNum_by_timesteps);

	const xs_3d_arr = await transform_2d_arr_to_3d_arr_batchSize_by_timesteps_by_featureNum(xs_2d_arr, batch_size, timesteps, featureNum);
	console.log('xs_3d_arr: ', xs_3d_arr);
	
	// -------------------------------------------------

	// Prepare the Y matrix
	
	// Since we want y to be a continuous value like in regression, and not a discrete value like in classification, let y be the point after each x. Shift x to the right by one or more data points.

	// Number of data points selected to forecast/predict
	const data_point_shift_between_X_and_Y = 1; 
	
	var ys_2d_arr = [];
	for (var i=0; i<featureNum; i++) {
		var ys_1d_arr_per_featureNum = await create_Y_by_timeShifting_X(xs_2d_arr.at(i), data_point_shift_between_X_and_Y);
		ys_2d_arr.push(ys_1d_arr_per_featureNum);
	}
	console.log('ys_2d_arr: ', ys_2d_arr);

	const ys_3d_arr = await transform_2d_arr_to_3d_arr_batchSize_by_timesteps_by_featureNum(ys_2d_arr, batch_size, timesteps, featureNum);
	console.log('ys_3d_arr: ', ys_3d_arr);
	
	// -------------------------------------------------
	
	// -----------------------------------------------
	
	// Predict future data points
	var model_type = document.getElementById("model_type").value;

	if (model_type == 'LSTM') {
		// document.getElementById('notification').innerHTML = "model_type In progress.";

		await build_lstmModel(batch_size, timesteps, num_of_features_OR_colnum, data_point_shift_between_X_and_Y)
			.then(async function(lstmModel) {
				await lstmModel.compile({optimizer: tf.train.adam(), loss: tf.losses.meanSquaredError, metrics: ['mse'],});
				return lstmModel;
			})
			.then(async function(lstmModel) { 
				const history = await lstmModel.fit(xs_3d_arr, ys_3d_arr, { 
					batchSize: batch_size, 
					epochs: 10, 
					callbacks: { onEpochEnd: async (epoch, logs) => { 
						console.log('epoch: ', epoch); 
						console.log('logs: ', logs); } 
						   } 
				});
				console.log('history: ', history);
				return lstmModel;
			})
			.then(async function(lstmModel) { 
				const saveResults = await lstmModel.save('localstorage://lstmModel');
				console.log('saveResults: ', saveResults);
			})
			.catch(error => console.error("error: ", error));
		
	} else if (model_type == 'Forecasting') {
		document.getElementById('notification').innerHTML = "model_type In progress.";

		var num_of_features_OR_colnum = 1; // number of columns in xs
		var num_of_outputs = 1;

		// Regression model
		const input = tf.input({shape: [num_of_features_OR_colnum]}); 
		const denseLayer1 = tf.layers.dense({units: 64, activation: 'relu'});
		const denseLayer2 = tf.layers.dense({units: 64, activation: 'relu'});
		const denseLayer3 = tf.layers.dense({units: 64, activation: 'relu'});
		const denseLayer4 = tf.layers.dense({units: num_of_outputs});  
		const output = denseLayer4.apply(denseLayer3.apply(denseLayer2.apply(denseLayer1.apply(input))));
		const model = tf.model({inputs: input, outputs: output});
		
		
	} else if (model_type == 'Transformer_based') {
		document.getElementById('notification').innerHTML = "model_type In progress.";

		// Step 0: Load a pretrained model 
		// https://js.tensorflow.org/api/latest/#loadLayersModel
		// const pretrained_model = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/savedmodel/tsmixer/model.json');
		// pretrained_model.summary();

		// Step 1: Find the desired layer and freeze layers or not
		// pretrained_model.layers.trainable = false;

		// Obtain a layer from the pretrained model

		
	} else {
		document.getElementById('notification').innerHTML = "Please select a model type for timeseries prediction."; 
	}

	// -----------------------------------------------
	
	// Evaluation of prediction with respect to existing prediction

	// -----------------------------------------------
	
}

// -----------------------------------------------




	
async function create_Y_by_timeShifting_X(X, data_point_shift_between_X_and_Y) {
	return X.slice(X.length-data_point_shift_between_X_and_Y, X.length).concat(X.slice(0, X.length-data_point_shift_between_X_and_Y));
}
	
// -----------------------------------------------

async function build_lstmModel(batch_size, timesteps, num_of_features_OR_colnum, data_point_shift_between_X_and_Y) {

	// returnSequences: true = prediction at each data point, false = prediction at each timestep (uses all the timestep data to make one prediction)
	// returnState: true = return the a and c matricies, false = do not return the a and c matricies
	
	var n_a = 8; // LSTMCell's number of units or hidden dimension size of the matrices (ie: a, c) used to compute the output
	
	// All predictions are per batch=batch_size. The amount of data points that one wants to use to obtain a prediction is called a timestep. The number of timesteps selected, dictates how many batches=batch_size that one needs to perform; data length divided by timesteps equals batch_size.

	// When one selects the timestep, LSTM automatically gives predictions for two cases only: 0. predictions for all the data points in the timestep per batch, or 1. one data point prediction at the end of the timestep per batch. 

	// To get more variety of prediction output number, I guess one could add a dense layer to change the number of outputs from 2 to timesteps-1 to capture the [data point shift between the X and Y data vectors].

	// The shift between the X and Y data vectors is how many data points one wants to predict into the future.

	const case_num = 1;
	// tf.input({shape: [batch_size, timesteps, num_of_features_OR_colnum]}) batch_size is calculated by LSTM so one does not need to write it
	const input = tf.input({shape: [timesteps, num_of_features_OR_colnum]});
	
	if (case_num == 0) {
		// Case 0: predictions for all the data points in the timestep per batch (most basic model)
		const lstm = tf.layers.lstm({units: n_a, returnSequences: true, returnState: false, kernelInitializer: 'heNormal'});
		// The output will be [all prediction per timesteps], which is 6 prediction per 6 data points, to give a prediction for [every hour] per 24 hours; returnSequences=true allows one prediction per data point.
		const output = lstm.apply(input);
		console.log("LSTM model output shape: ", JSON.stringify(output.shape));  // [batch_size, timesteps, n_a]
		return await tf.model({inputs: input, outputs: output});

	} else if (case_num == 1) {
		// Case 1: one data point prediction at the end of the timestep per batch (most basic model)
		const lstm = tf.layers.lstm({units: n_a, returnSequences: false, returnState: false, kernelInitializer: 'heNormal'});
		// The output will be [one prediction per timesteps], which is 1 prediction per 6 data points, to give a prediction for [morning, noon, afternoon, night] per 24 hours; returnSequences=false allows one prediction per timesteps.
		const output = lstm.apply(input);
		console.log("LSTM model output shape: ", JSON.stringify(output.shape));  // [batch_size, timesteps, n_a]
		return await tf.model({inputs: input, outputs: output});

	} else if (case_num == 2) {
		// Case 2: Forecasting - predictions for all the data points in the timestep per batch, but limit prediction output number from 2 to timesteps-1
		// const input = tf.input({shape: [timesteps, num_of_features_OR_colnum]});
		const lstm = tf.layers.lstm({units: n_a, returnSequences: true, returnState: false, kernelInitializer: 'heNormal'});
		const dropout = tf.layers.dropout({rate: 0.2});
		// If returnSequences = true, there will be [one prediction per data point every batch] so one could reduce the number of 'regression-like' outputs to a number from 2 to timesteps-1.  If one wanted 1 output only, set returnSequences = false to obtain one prediction per timestep.
		var num_of_outputs = data_point_shift_between_X_and_Y; // a value from 2 to timesteps-1, or the number of data points to predict into the future
		const denseLayer1 = tf.layers.dense({units: num_of_outputs, activation: 'linear'});
		const output = denseLayer1.apply(dropout.apply(lstm.apply(input)));
		console.log("LSTM model output shape: ", JSON.stringify(output.shape));  // [batch_size, timesteps, n_a]
		return await tf.model({inputs: input, outputs: output});
	
	} else if (case_num == 3) {
		// Case 3: Classification prediction of timeseries class - one data point prediction at the end of the timestep per batch
		var num_of_classes = 2;  // 2 or more
		const lstm = tf.layers.lstm({units: n_a, returnSequences: false});
		const denseLayer1 = tf.layers.dense({units: num_of_classes, activation: 'softmax'});
		const output = denseLayer1.apply(lstm.apply(input));
		console.log("LSTM model output shape: ", JSON.stringify(output.shape));  // [batch_size, timesteps, n_a]
		return await tf.model({inputs: input, outputs: output});
	}
}

// -----------------------------------------------
	
async function transform_2d_arr_to_3d_arr_batchSize_by_timesteps_by_featureNum(X2Darr, batch_size, timesteps, featureNum) {

	// Way 2: First focus on folding the data by [timesteps, featureNum], then stack up these 2D arrays per batch_size
	// Tensorflow.js (tf.layers.lstm): "Create an input with [timesteps] time steps."
	// const input = tf.input({shape: [timesteps, featureNum]});
	// So it means that [timesteps] are the rows, and [featureNum] are the columns
	var x_batchSize_by_timesteps_by_featureNum = [];
	for (var i=0; i<batch_size; i++) {
		var x_timesteps_by_featureNum = [];
		for (var j=0; j<timesteps; j++) {
			var x_featureNum = [];
			for (var k=0; k<featureNum; k++) {
				x_featureNum.push(X2Darr[k].at(j));
			}
			x_timesteps_by_featureNum.push(x_featureNum);
		}
		x_batchSize_by_timesteps_by_featureNum.push(x_timesteps_by_featureNum);
	}
	console.log('x_batchSize_by_timesteps_by_featureNum: ', x_batchSize_by_timesteps_by_featureNum);

	// Shape [batch_size, timesteps, featureNum]
	const xs_3D = await tf.tensor3d(x_batchSize_by_timesteps_by_featureNum, [batch_size, timesteps, featureNum]);
	console.log('xs_3D: ', xs_3D);
	
	return xs_3D;
}

// -----------------------------------------------
	
async function GET_LATITUDE_LONGITUDE(LOCATION) {
	
	// [Step 0] Get latitude and longitude
	// https://maps.googleapis.com/maps/api/geocode/json?address=${address}&key=${GCP_API_KEY}
	// OR
	// https://nominatim.org/release-docs/latest/api/Search/
	var url = `https://nominatim.openstreetmap.org/search?q=${LOCATION}&format=json`;
	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var headers = {};
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	var out = await fetch_CORS(url, method, data, headers, return_type);
	console.log('out: ', out); 

	// Parse for correct location: choose the first location because it will be most precise
	return [Number(out[0].lat), Number(out[0].lon)];
}

// -----------------------------------------------
	
async function GET_weather_timeseries_data(latitude, longitude) {
	
	// [Step 0] Get weather data
	// https://open-meteo.com/en/docs
	// The API endpoint /v1/forecast accepts a geographical coordinate, a list of weather variables and responds with a JSON hourly weather forecast for 7 days. Time always starts at 0:00 today and contains 168 hours. If &forecast_days=16 is set, up to 16 days of forecast can be returned.

	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var headers = {};
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'

	// --------------------------------
	
	// Obtain weather [temperature] data from the past (Prediction)
	// Return temperature every hour for the [previous 2 days OR more], such that the next day can be predicted
	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m&past_days=2&forecast_days=0`;
	var open_meteo_past_data = await fetch_CORS(url, method, data, headers, return_type);
	console.log('open_meteo_past_data: ', open_meteo_past_data);

	// --------------------------------
	
	// Obtain weather [temperature] predictions by open-meteo (Actual)
	// Return temperature every hour for the next day
	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m&past_days=0&forecast_days=1`;
	var open_meteo_predictions = await fetch_CORS(url, method, data, headers, return_type);
	console.log('open_meteo_predictions: ', open_meteo_predictions);

	return [open_meteo_past_data.hourly, open_meteo_predictions.hourly];
}

// -----------------------------------------------



	
// -----------------------------------------------
// CORS methods
// -----------------------------------------------
async function fetch_CORS(url, method, data, headers, return_type) {

	// url: url address
	// method: 'GET', 'POST'
	// data: required data format for url address
	var w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	// return_type: json, blob, arrayBuffer, text

	// --------------------------------

	// Determine request method
	var headers_final = {
		"Content-Type": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};

	
	headers_final = Object.assign({}, headers_final, headers);
	
	var options = { 
		method : method,
		mode: 'cors',
		headers: new Headers(headers_final),
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

	if (method == 'POST') {
		options.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.json())
				.then(async function(data) { return data; })
				.catch(error => console.error("error: ", error));
		} else { 
			return await fetch(url, options)
				.then(response => response.json())
				.then(async function(data) { return data; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'arrayBuffer') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { return arraybuffer; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { return arraybuffer; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'text') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		}

	} else if (return_type == 'html') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		}
	}

	// --------------------------------
}


async function define_proxy_handler() {
	// Parameters to influence Response Header
	// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
	const handler = {
		apply: function(target, thisArg, args) {
			// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
			const [url, options] = args;
			if (options && options.headers) {
				options.headers['Access-Control-Allow-Origin'] = '*';
				options.headers['Access-Control-Allow-Credentials'] = false;
				options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
				// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
				options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
				options.headers['Access-Control-Max-Age'] = 0;
			} else {
				args[1] = {
					headers: { 
						'Access-Control-Allow-Origin': '*',
						'Access-Control-Allow-Credentials': false,
						'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
						'Access-Control-Allow-Headers': 'Content-Type, Authorization',
						'Access-Control-Max-Age': 0
					}
				};
			}
			// console.log('args: ', args);
			return Reflect.apply(target, thisArg, args);
		}
	};

	// Proxy sturcture works! 
	// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
	// The constant variable is called as a function, where it resolves promises. 
	// Call the constant variable proxy3 as a function to resolve the promise correctly
	return await new Proxy(fetch, handler);
}

// -----------------------------------------------


</script>

  
</body>
</html>
